# pytest functions for decorators

# Generated by CodiumAI

from hsi_wizard._utils.decorators import check_path
from hsi_wizard._utils.decorators import check_time
from hsi_wizard._utils.decorators import check_limits
from hsi_wizard._utils.decorators import add_method


import time
import pytest
import numpy as np

VALID_PATH = '.'


class TestCheckPath:

    #  Function called with valid path
    def test_valid_path(self):
        @check_path
        def dummy_func(path):
            return True

        assert dummy_func(VALID_PATH) == True

    #  Function called with valid path and additional arguments
    def test_valid_path_with_args(self):
        @check_path
        def dummy_func(path, arg1, arg2):
            return True

        assert dummy_func(VALID_PATH, 'arg1', 'arg2') == True

    #  Function called with valid path and keyword argument
    def test_valid_path_with_kwarg(self):
        @check_path
        def dummy_func(path, kwarg=None):
            return True

        assert dummy_func(VALID_PATH, kwarg='value') == True

    #  Function called with valid path and multiple keyword arguments
    def test_valid_path_with_multiple_kwargs(self):
        @check_path
        def dummy_func(path, kwarg1=None, kwarg2=None):
            return True

        assert dummy_func(VALID_PATH, kwarg1='value1', kwarg2='value2') == True

    #  Function called with empty string path
    def test_empty_string_path(self):
        @check_path
        def dummy_func(path):
            return True

        with pytest.raises(ValueError):
            dummy_func('')

    #  Function called with non-existent path
    def test_nonexistent_path(self):
        @check_path
        def dummy_func(path):
            return True

        with pytest.raises(FileNotFoundError):
            dummy_func('/path/to/nonexistent')


class TestCheckTime:

    #  The function should correctly measure the execution time of the provided function.
    def test_correct_execution_time(self):
        @check_time
        def func():
            time.sleep(1)
        result = func()
        assert result >= 1.0

    #  The function should return the execution time of the provided function.
    def test_return_execution_time(self):
        @check_time
        def func():
            time.sleep(1)
        result = func()
        assert isinstance(result, float)

    #  The function should accept any function as input.
    def test_accept_any_function(self):
        @check_time
        def func():
            pass
        result = func()
        assert result is not None

    #  The function should correctly handle functions with no arguments.
    def test_no_arguments(self):
        @check_time
        def func():
            pass
        result = func()
        assert result is not None

    #  The function should correctly handle functions with positional arguments.
    def test_positional_arguments(self):
        @check_time
        def func(a, b):
            pass
        result = func(1, 2)
        assert result is not None

    #  The function should correctly handle functions that raise exceptions.
    def test_raise_exceptions(self):
        @check_time
        def func():
            raise ValueError
        try:

            result = func()
        except ValueError:
            assert True
        else:
            assert False

    #  The function should correctly handle functions that take a long time to execute.
    def test_long_execution_time(self):
        @check_time
        def func():
            time.sleep(5)
        result = func()
        assert result >= 5.0

    #  The function should correctly handle functions with keyword arguments.
    def test_keyword_arguments(self):
        @check_time
        def func(a, b):
            pass
        result = func(a=1, b=2)
        assert result is not None

    #  The function should correctly handle functions with both positional and keyword arguments.
    def test_positional_and_keyword_arguments(self):
        @check_time
        def func(a, b, c=3):
            pass
        result = func(1, b=2)
        assert result is not None


class TestCheckLimits:

    #  The function receives an image with all values equal to the upper limit and returns the same image.
    def test_all_values_equal_to_upper_limit_returns_same_image(self):
        # Arrange
        image = np.array([[1, 1], [1, 1]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an image with all values equal to the lower limit and returns the same image.
    def test_all_values_equal_to_lower_limit_returns_same_image(self):
        # Arrange
        image = np.array([[0, 0], [0, 0]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an empty image and returns an empty image.
    def test_empty_image_returns_empty_image(self):
        # Arrange
        image = np.array([], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an image with a single value and returns the same image.
    def test_single_value_image_returns_same_image(self):
        # Arrange
        image = np.array([100], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, [1.])

    #  The function receives an image with negative values and returns the clipped image.
    def test_negative_values_returns_clipped_image(self):
        # Arrange
        image = np.array([[-100, -200], [150, 250]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, np.array([[0., 0.], [1., 1.]], dtype='float32'))

    #  The function receives an image with values above the upper limit and returns the clipped image.
    def test_values_above_upper_limit_returns_clipped_image(self):
        # Arrange
        image = np.array([[300, 400], [500, 600]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, np.array([[1, 1], [1, 1]], dtype='float32'))


class TestAddMethod:

    #  The decorator function should return a function.
    def test_decorator_returns_function(self):

        class MyClass:
            pass

        @add_method(MyClass)
        def my_method():
            return None

        assert callable(MyClass.my_method)
